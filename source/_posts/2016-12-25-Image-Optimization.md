---
title: Оптимизация графики для web
date: 2016-12-25 20:08:43
tags: [translate, web, webp, perfomance, JPEG-XR, JPEG-2000]
cover: /images/20161214/1.jpg
description: Я не использую препроцессоры, а точнее, никогда не использую в своих личных проектах, так как препроцессоры для меня, это решение с дополнительными проблемами.
---
Это перевод статьи [Image Optimization](http://calendar.perfplanet.com/2016/image-optimization/) автора [Estelle Weyl](http://www.standardista.com/).

Наверное, каждый веб-разработчик знает, что когда речь заходит о производительности и удобстве ипользования (UX) каждое изображение на странице имеет оргомное значение: первые плоды в оптимизации web-страниц может принести именно работа с изображениями. Использование методик сжатия изображений без потерь качества позволяет снизить суммарный размер страницы не нанося ущерба пользовательскому опыту (UX) работы с такими страницами, тем самым, улучшая производительность и увеличивая конверсию. Существует много методов для определения того, какие изображения поддерживаются, и вам остается только подготовить "правильные" изображения и отдать их пользователю. Создание оптимальных изображений для всех пользователей на всех типах устройств должно стать целью всех разработчиков (доступность должна стать еще одной целью, но сейчас не об этом).
<!-- more -->

Как определить какое изображение показать
------------
Существует несколько методик для отображения нужного изображения, например, медиа запросы при использовании фоновых изображений, или использование элементов `<picture>` и `<source>` совместно с `srcset`.
Используя `CSS @media queries` можно отображать различные фоновые изображения в зависимости от размера окна просмотра или плотности пикселей на устройстве пользователя.

Например, вы можете показать изображение lowres.jpg для старых ноутбуков и hires.jpeg для iPad Pro:
```css
header {
   background-image: url(img/hires_header.jpg);
}

@media only screen and (min-device-pixel-ratio: 2) and (min-width: 1024px) {
   header {
       background-image: url(img/hires_header.jpg);
   }
}
```

А как быть с обычными изображениями переднего плана?

Методика [адаптивных изоражений](http://www.standardista.com/responsive-images-clown-car-technique/) еще с 2013 года была основана на том, что SVG имеет свою свобственную ширину и высоту контейнера, и медиавыражения в них отталкиваются от этих размеров, а не от размеров окна браузера (viewport).
К счастью, текущая поддержка браузерами тега `<picture>` и `srcset` позволяют не использовать уже этот хак.

Основоной проблемой в изображениях переднего плана является то, что браузер имеет информацию о размере экрана (viewport) и плотности пикселей на экране, но понятия не имеет о размере загружаемого изображения и того, как оно соотносится с размером экрана. Но, разработчик знает и может указывать их.

Подобно медиазапросам при помощи тегов `<picture`, `<source>` и атрибута `srcset` разработчик может диктовать браузеру какие изображения отображать для того или иного размера экрана или плотности пикселей.
```html
<picture>
   <source srcset="small_lowres.jpg, small_highres.jpg 2x" media="(max-width: 768px)">
   <source srcset="default.jpg, default_highres.jpg 2x">
   <source srcset="large_lowres.jpg, large_highres.jpg 2x" media="(min-width: 1024px)">
   <img src="default.jpg" alt="image descriptor">
</picture>
```
>Примечание! Всегда используйте по умолчанию тег `<img>` внутри каждого `<picture>`, а также атрибут `alt` для тега.

Вы можете использовать просто тег `<img>` без использования `<picture>` и в теге `img` указать атрибуты `srcset` с набором изоражений и `sizes` для описания области их применения.

```html
<img src="default.jpg"
  srcset="large.jpg 1024w,
        medium.jpg 768w,
        default.jpg 420w"
  sizes="(min-width: 1024px) 1024px,
       (min-width: 768px) 90vw,
       100vw"
  alt="image descriptor" />
```

Мы также можем отображать различные типы изображений используя атрибут `type`:

```html
<picture>
   <source srcset="photo.jxr" type="image/vnd.ms-photo">
   <source srcset="photo.jp2" type="image/jp2">
   <source srcset="photo.webp" type="image/webp">
   <img srcset="photo.jpg" alt="My beautiful face">
</picture>
```

Если вас удивляет код выше, JPEG-XR старый MIME image/vnd.ms-photo для Windows Media Photo, проприетарный формат изображений от Microsoft, поддерживаемый IE8 и выше, включая Microsoft Edge. jp2 – это расширение для формата JPEG 2000, который поддерживается браузером Safari. WebP – это формат изоюражений со сжатием без потерь качества и поддерживается на данный момент браузерами Chrome и Opera. А Firefox будет поддерживать форматы графики, как PNG-A, SVG, GIF и JPEG (как в коде выше).

*Chrome* – **WebP**
*IE 9+ / Edge* – **JPEG-XR**
*Opera* – **WebP**
*Safari* – **JPEG-2000**

Для Firefox и IE8 нужно предусмотреть запасной вариант в виде изображений JPEG или PNG. И хотя Safari и Firefox экспериментируют с поддержкой WebP изображений, пока нет уверенности в том, что такая поддержка вскоре появится. В любом случае, можно проверить поддержку на сайте [Can I Use](http://caniuse.com/#search=webp).

Для более детального изучения возможностей есть хорошие онлайн учебники для [медиавыражений](https://www.smashingmagazine.com/2013/07/simple-responsive-images-with-css-background-images/), [тега `<picture>`](https://cloudfour.com/thinks/responsive-images-101-definitions/) и [srcset](https://www.sitepoint.com/how-to-build-responsive-images-with-srcset/).

Сложность и количество кода
------------

Основной пролемой в таком решении (смотри код выше), это большое количество кода, который необъодимо написать для того, чтоб покрыть как можно больше вариантов размеров экранов и плотностей пикселей. Расставить контрольные точки для каждого разрешения безусловно можно, но это сложно, и вы врядли хотели бы этим заниматься вручную. К счастью, для написания таких условий можно и нужно автоматихировать.

Оптимальным решением в том случае будет генерация кода на стороне сервера под три из четырех основных критериев, таких как: размер окна (viewport), плотность пикселей, поддержка клиентом формата изображения и отношение размера изображения к размеру экрана. Почему три из четырех? Вы всегда можете использовать все преимущества понимания браузером sourcesets, но вы не используете все комбинации, а лишь некоторые из них.

Если ваш DOM формируется в браузере только на клиентской стороне при помощи JavaScript, например, как у React приложений, имея информацию о клиентском устройстве вы можете запросить правильное изображение, но пользователи будут какое-то время видеть частично загруженный экран (в то время, пока обрабатывается код на клиенте).

![Скриншот профайлера Google Chrome](/images/20161225/CstkNXeVMAAEgvL.jpg "Скриншот профайлера Google Chrome")

В том случае, когда вы не генерируете весь HTML на стороне клиента, подмена пути к изображению тоже не будет оптимальным решением, так как во время парсинга документа браузер начнет скачивать оригинальное изображение, а затем, когда отработает JavaScript, браузер приступит к скачиванию другого, более оптимального для него, изображения.

И если вы являетесь сторонником прогрессивного улушения, вы должны понимать, что исходное изображение будет загружено в любом случае после того как HTML документа будет проанализирован.

К сожалению, подсказки, которые отправляются на сервер с информацией о плотности пикселей экрана или поддержкой WebP, в виде заголовков HTTP запросов были реализованы только в Blink (Chrome и Opera). Когда вы имеете информацию о разрешении и размере экрана пользователя вы можете автоматически отдавать правильные изображения используя прогрессивное улучшение на стороне сервера. При помощи таких заголовков мы можем определить поддержку формата изображения WebP (Chrome и Opera поддерживают такие типы заголовков), разрешение и размер окна устройства клиента. В Instart Logic у нас есть скрипт под названием Nanovisor, который повторяет функциональность HTTP заголовков для браузеров, которые не поддерживают эту технологию, что позволяет нам отправлять клиенту оптимизированные изображения.

Вы можете также анализировать строку загловка UserAgent вместе с некоторой дополнительной информацией для того, чтобы определить тип поддерживаемых графических файлов у конкретного пользователя. Узнав это, вы можете подменить расширение файла или можете отдать изображение нужного формата но с "неправильным" расширением. Например, если пользователь запросил файл foo.jpg мы можем отдеть ему нужный тип файла, под все тем же именем foo.jpg. В Instart Logic мы отдаем пользователям WebP для Chrome и Opera, и JPEG-XR для Edge без изменения имени файла, мы просто всегда используем .jpg в конце имени файла. Мы пользуемся тем фактом, что все браузеры корректно отображают изображения руководствуясь MIME не обращая внимания на расширение файлов. Таким образом, мы можете создавать одну и туже разметку html для разных браузеров, а со стороны сервера отдавать кажому браузеру нужное изображение.

Если вы собираетесь генерировать различные форматы изображений на основе поддерки браузером, но с одним расширением файла, вы должны обеспечить сохранение (кеш) изображений на стороне сервера и как-то разделять изображения с одним именем и разным типом содержимого. Либо вам нужно со стороны клиента слать запросы с нужных разширением файла. Если вы знаете лучшее или еще одно решение, дайте мне знать.

Automating the asset creation process
------------
